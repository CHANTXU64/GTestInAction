# 独立的测试工程

在生产环境中，会将测试代码放在一个单独的project中，测试代码与实际的代码在不同的工程中，在项目发布版本的时候，只需要将实际的代码工程发布，测试代码不会混在一起；在CI环境中，可以写独立的脚本运行特定的工程。

## 创建模拟动态链接库工程
这里，我创建一个单独的工程，名字叫做SampleDynamicLibrary，用来模拟实现一个动态链接库，添加一个头文件和一个源文件，实现一个全局int类型数据的加法操作。
代码如下：

```C++
// DynamicSample.h
#pragma once

__declspec(dllexport) int GlobalAdd(int a, int b);
```

```C++
#include "../Headers/DynamicSample.h"

int GlobalAdd(int a, int b)
{
    return a + b;
}
```

然后，修改项目属性，将General-> Congifuration Type修改成Dynamic Library，默认是Application。

模拟项目就完成了。

## 创建测试工程

测试工程的创建与前面几个工程类似，首先创建一个空的C++工程，然后添加Google Test的属性表，添加一个包含main函数的文件，简单起见，我们直接在这一个文件中完成测试。
源文件代码如下：

```c++
#include <gtest/gtest.h>
#include "../SampleDynamicLibrary/Headers/DynamicSample.h"

TEST(DynamicTes, test)
{
    EXPECT_EQ(2,GlobalAdd(1, 1));
}

int main(int argc, char** argv)
{
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```

在当前的测试工程，添加reference，把刚刚的创建的模拟工程添加到reference。

然后就可以运行了。
如下图所示，表示运行结果：
![动态库测试结果](https://github.com/zhangxiaoya/GTestInAction/blob/master/ActionFour/dynamicTestResult.PNG)

## 创建模拟静态库工程

静态库的测试与动态库的测试一样，不同的是，不想动态库添加到处动态库的声明，如下是静态库的测试代码：

```C++
// StaticSample.h
#pragma once

int GlobalMinus(int a, int b);
```

```C++
#include "../Headers/StaticSample.h"

int GlobalMinus(int a, int b)
{
    return a - b;
}

```

然后，修改测试工程，添加测试静态库的代码：

```C++
TEST(StaticLibaray, test)
{
    EXPECT_EQ(1, GlobalMinus(2, 1));
}
```

如下图所示，表示测试结果：
![静态库测试结果](https://github.com/zhangxiaoya/GTestInAction/blob/master/ActionFour/staticTestResult.PNG)

## 动态库测试问题

在[Google Test primer](https://github.com/google/googletest/blob/master/googletest/docs/Primer.md)中有这样一段描述。

> **Important note for Visual C++ users**
> If you put your tests into a library and your main() function is in a different library or in your .exe file, those tests will not run. The reason is a bug in Visual C++. When you define your tests, Google Test creates certain static objects to register them. These objects are not referenced from elsewhere but their constructors are still supposed to run. When Visual C++ linker sees that nothing in the library is referenced from other places it throws the library out. You have to reference your library with tests from your main program to keep the linker from discarding it. Here is how to do it. Somewhere in your library code declare a function:

```c++
__declspec(dllexport) int PullInMyLibrary() { return 0; }
```

> If you put your tests in a static library (not DLL) then `__declspec(dllexport)` is not required. Now, in your main program, write a code that invokes that function:

```C++
int PullInMyLibrary();
static int dummy = PullInMyLibrary();
```

> This will keep your tests referenced and will make them register themselves at startup.
> In addition, if you define your tests in a static library, add /OPT:NOREF to your main program linker options. If you use MSVC++ IDE, go to your .exe project properties/Configuration Properties/Linker/Optimization and set References setting to Keep Unreferenced Data `(/OPT:NOREF)`. This will keep Visual C++ linker from discarding individual symbols generated by your tests from the final executable.
> There is one more pitfall, though. If you use Google Test as a static library (that's how it is defined in gtest.vcproj) your tests must also reside in a static library. If you have to have them in a DLL, you must change Google Test to build into a DLL as well. Otherwise your tests will not run correctly or will not run at all. The general conclusion here is: make your life easier - do not write your tests in libraries!

简单来说，在Visual C++ 中有一个Bug，在引用动态库的中一个对象或者函数时，只有编译器能够推断出这些对象能够被构建时，才能正确的引用，但是动态链接库是在运行时才能知道定义，所以不能推断出被初始化，所以，使用动态链接库的时候，声明动态链接库的函数时候，需要额外添加`__declspec(dllexport) `，这个只是在动态库中的函数声明的时候才添加，在函数定义的时候不用添加，静态库没有这样的问题。

## 参考

1. [Google Test Primer](https://github.com/google/googletest/blob/master/googletest/docs/Primer.md)
1. [有关同一解决方案下多个工程相互调用的问题](http://blog.csdn.net/chenyang648899/article/details/51145922)